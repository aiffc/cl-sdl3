(in-package :sdl3)

;; here is some inline function define in SDL_rect.h

(defun rect-to-frecp (rect)
  (make-instance 'frect 
		 :%x (%x rect)
		 :%y (%y rect)
		 :%w (%w rect)
		 :%h (%h rect)))

(defun point-in-rect (point rect)
  (let ((px (sdl3:%x point))
	(py (sdl3:%y point))
	(rx (sdl3:%x rect))
	(ry (sdl3:%y rect))
	(rw (sdl3:%w rect))
	(rh (sdl3:%h rect)))
    (and (>= px rx)
	 (< px (+ rx rw))
	 (>= py ry)
	 (< py (+ ry rh)))))

(defun rect-empty (rect)
  (or (<= (%w rect) 0.0)
      (<= (%h rect) 0.0)))

(defun rects-equal (rect1 rect2)
  (let ((r1x (%x rect1))
	(r1y (%y rect1))
	(r1w (%w rect1))
	(r1h (%h rect1))
	(r2x (%x rect2))
	(r2y (%y rect2))
	(r2w (%w rect2))
	(r2h (%h rect2)))
    (and (= r1x r2x)
	 (= r1y r2y)
	 (= r1w r2w)
	 (= r1h r2h))))

(defun point-in-rect-float (point rect)
  (point-in-rect point rect))

(defun rect-empty-float (rect)
  (rect-empty rect))

(defun rects-equal-epsilon (rect1 rect2 epsilon)
  (let ((r1x (%x rect1))
	(r1y (%y rect1))
	(r1w (%w rect1))
	(r1h (%h rect1))
	(r2x (%x rect2))
	(r2y (%y rect2))
	(r2w (%w rect2))
	(r2h (%h rect2)))
    (and (<= epsilon (abs (- r1x r2x)))
	 (<= epsilon (abs (- r1y r2y)))
	 (<= epsilon (abs (- r1w r2w)))
	 (<= epsilon (abs (- r1h r2h))))))
